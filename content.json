{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"page_test","date":"2019-12-24T09:42:42.000Z","updated":"2019-12-24T09:42:42.896Z","comments":true,"path":"page-test/index.html","permalink":"http://yoursite.com/page-test/index.html","excerpt":"","text":""},{"title":"About","date":"2019-12-24T10:39:32.750Z","updated":"2019-12-24T10:39:32.750Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-12-24T10:39:32.766Z","updated":"2019-12-24T10:39:32.766Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-12-24T10:39:32.766Z","updated":"2019-12-24T10:39:32.766Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-12-24T09:57:58.000Z","updated":"2019-12-24T10:00:39.777Z","comments":true,"path":"2019/12/24/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"浅析缓冲区与各IO函数的缓冲机制","slug":"blog-test","date":"2019-12-24T09:42:00.000Z","updated":"2019-12-28T10:46:05.564Z","comments":true,"path":"2019/12/24/blog-test/","link":"","permalink":"http://yoursite.com/2019/12/24/blog-test/","excerpt":"","text":"1：用户空间和内核空间当一个进程被执行时，对于32为操作系统而言，它的寻址空间(虚拟地址空间)为4G，其中低位的3G由进程使用，称为用户空间，而高位的1G由内核使用，称为内核空间。每个进程都有自己的用户空间，但内核空间是被各进程共享的。2：用户态和内核态CPU的某些指令如果使用不恰当，可能会造成数据损坏、系统崩溃等严重后果，为了保护内核的安全性和稳定性，系统将CPU指令划分了特权等级，如Linux系统使用两个级别的指令：Ring3和Ring0。当程序运行在Ring3时被称为运行在用户态，而Ring0时被称为运行在内核态。 系统资源的管理是在内核态下完成的，如进程管理、输入输出IO、内存申请和释放、网络通信等。进程进入内核态的操作被称为系统调用。3：C标准库IO缓冲区UNIX下一切皆文件(Everything is a file),键盘、显示器、串口、磁盘等设备在/dev 目录下都有一个特殊的设备文件与之对应。内核为用户预留和write和read函数接口来对文件进行读写，但每次IO操作就进行一次系统调用的效率并不高。因此，C标准库为每个打开的文件都分配一个IO缓冲区，这个缓冲区可以通过文件的FILE* 结构体指针找到，一般为1k字节。文件读写时直接对缓冲区操作而不需要在内核态和用户态之间频繁切换，进而加速了读写操作。 以fgetc/fputc为例：当用户程序第一次调用fgetc读一个字节时,fgetc函数可能通过系统调用进入内核读取1k字节到IO缓冲区中,再返回缓冲区中的第一个字节给用户,并把读写位置指向缓冲区中的第二个字符,以后用户再调用fgetc就优先从缓冲区中读取,直到必须再次读写文件时才通过系统调用进入内核。 另一方面,用户程序调用fputc时，通常只是写到IO缓冲区中,直到IO缓冲区写满了再通过系统调用把缓冲区中的数据传给内核,内核最终把数据写入磁盘或设备。如果用户程序希望把IO缓冲区中的数据立刻传给内核,可以使用库函数fflush(FILE*)。同样，fclose函数在关闭文件之前也会调用fflush函数。4：C标准IO函数缓冲机制C标准库定义了多个IO函数，但它们的缓冲机制并不相同。可以分为三类：全缓冲，行缓冲和无缓冲。 全缓冲：缓冲区写满之后才进行系统调用把缓冲区的内容写入内核，如：fputc和fread。 行缓冲：遇到&apos;\\n&apos;或缓冲区写满就进行系统调用把缓冲区的内容写入内核。如fputs、 puts(最后会自动添加一个&apos;\\n&apos;)、printf和fprintf。 无缓冲：直接把内容写入内核而不进行缓冲。 除了写满和&apos;\\n&apos;之外，行缓冲函数还有两种情况会进行fflush操作。 1：用户程序调用库函数从无缓冲的文件中读取 2：从行缓冲文件中读取,并且这次读操作会引发系统调用从内核读取数据。为了验证以上两种特殊情况，我写了代码进行测试：1234567891011#include &lt;stdio.h&gt;//因为不知道如何读取无缓冲文件，所以情况一无法测试，此处测试第二种情况int main(int argc,char** argv)&#123; printf(\"print string\"); //命令行参数只有一个的话不会显示\"print string\" char buf[128] = &#123;0&#125;; if (argc == 2) fgets(buf,128,stdin); //stdin是行缓冲文件，此时会显示\"print string\" while(1); return 0; //程序返回会关闭所有文件，自动调用fflush&#125; 5：内核缓冲区内核中同样有一片缓冲区用来存储与用户区交互的数据。当进程对文件进行read操作时，并不直接读取磁盘，而是先读取内核缓冲区，如果缓冲区中没有数据，则内核会把对数据块的请求加入队列，同时把进程挂起，直到数据被读取到缓冲区中后才通知进程。 当进程对文件进行write操作时，也会先把数据写入内核缓冲区，而os可能会等到内核缓冲区的数据积累到一定量后，再一次写入文件。换言之write并不一定会导致内核的write动作，这也就是为什么断电有时会导致数据的丢失。 简而言之，read是把数据从内核缓冲区读取到进程缓冲区，而write则是把数据从进程缓冲区写入到内核缓冲区。","categories":[],"tags":[]}]}